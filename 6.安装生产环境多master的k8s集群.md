# 安装生产环境多master的k8s集群

## 最终效果图

- Pod网段：   10.0.0.0/16
- Service网段：  10.255.0.0/16

![image-20220625131054661](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625131054661.png)

## 设定

实验环境规划：
操作系统：centos7.6
配置： 4Gib内存/6vCPU/100G硬盘
注意：也可以用4vCPU
网络：NAT
开启虚拟机的虚拟化：

| K8S集群角色 | Ip            | 主机名  | 安装的组件                                                   |
| ----------- | ------------- | ------- | ------------------------------------------------------------ |
| 控制节点    | 192.168.2.128 | master1 | apiserver、controller-manager、scheduler、etcd、docker、keepalived、nginx |
| 控制节点    | 192.168.2.129 | master2 | apiserver、controller-manager、scheduler、etcd、docker、keepalived、nginx |
| 控制节点    | 192.168.2.130 | master3 | apiserver、controller-manager、scheduler、etcd、docker       |
| 工作节点    | 192.168.2.131 | node    | kubelet、kube-proxy、docker、calico、coredns                 |
| Vip         | 192.168.2.132 | vip     |                                                              |

ps:192.168.2.132只是虚拟ip。不需要安装虚拟机。

vmare的net模式配置截图

<img src="https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625125354294.png" alt="image-20220625125354294" style="zoom: 80%;" />

## 初始化

### 设置ip

<font color="green">操作服务器：master1、master2、master3、node</font>

检查ip设置是否为固定ip，如果不是固定ip需要设置。设置步骤如下：

```sh
ip addr
```

检查网卡，在这一步我是ens33

![image-20220625125652519](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625125652519.png)

修改ifcfg-ens33配置文件

```sh
vi /etc/sysconfig/network-scripts/ifcfg-ens33
```

```sh
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="ens33"
UUID="4faacdfd-bce5-4ed8-b248-1d4c4a98bb6b"
DEVICE="ens33"
ONBOOT="yes"
IPADDR="192.168.2.128"
NETMASK="255.255.255.0"
GATEWAY="192.168.2.2"
DNS1="8.8.8.8"
DNS2="8.8.4.4"
```

注意：一定要设置DNS1，不然会出现无法连接外网情况。一般如果是默认情况只需要修改`BOOTPROTO`为static静态模式。<font color="red">DNS一定要正确，不然在安装docker的时候也会提示错误</font>。并追加以下配置

```sh
IPADDR="192.168.2.128"
NETMASK="255.255.255.0"
GATEWAY="192.168.2.2"
DNS1="8.8.8.8"
DNS2="8.8.4.4"
```

修改完毕，重启network服务

```sh
systemctl restart network
```

如果xshell没有断开连接并且能够ping通百度即可。

<font color="red">其余四台服务器一样设置</font>

### 设置主机名

检查主机名是否为对应的名字

| K8S集群角色 | Ip            | 主机名  |
| ----------- | ------------- | ------- |
| 控制节点    | 192.168.2.128 | master1 |
| 控制节点    | 192.168.2.129 | master2 |
| 控制节点    | 192.168.2.130 | master3 |
| 工作节点    | 192.168.2.131 | node    |
| Vip         | 192.168.2.132 | vip     |

语法：

```sh
hostnamectl set-hostname <主机名>
bash
```

### 配置/etc/hosts文件

<font color="green">操作服务器：master1、master2、master3、node</font>

目的：能够通过名字直接访问主机

cat /etc/hosts

```sh
192.168.2.128   master1
192.168.2.129   master2
192.168.2.130   master3
192.168.2.131   node
```

运行结果如下

```sh
[root@vip ~]# cat >>/etc/hosts <<EOF
> 192.168.2.128   master1
> 192.168.2.129   master2
> 192.168.2.130   master3
> 192.168.2.131   node
> EOF
[root@vip ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.2.128   master1
192.168.2.129   master2
192.168.2.130   master3
192.168.2.131   node
```

可以尝试执行

```shell
ping master1
ping master2
ping master3
ping node
```

检查ip解析是否正确。

### ssh登录

<font color="green">操作服务器：master1、master2、master3、node</font>

生成ssh密钥对

目的：服务器之间，可以免密连接。

步骤：

生成密钥

```sh
ssh-keygen -t rsa
```

一直回车即可。

发送文件到其他服务器

```sh
ssh-copy-id -i /root/.ssh/id_rsa.pub master1#回车以后，输入yes，输入服务器密码
ssh-copy-id -i /root/.ssh/id_rsa.pub master2#回车以后，输入yes，输入服务器密码
ssh-copy-id -i /root/.ssh/id_rsa.pub master3#回车以后，输入yes，输入服务器密码
ssh-copy-id -i /root/.ssh/id_rsa.pub node   #回车以后，输入yes，输入服务器密码
```

测试：

```sh
ssh master1
ssh master2
ssh master3
ssh node
```

以master2为例

![image-20220625133543123](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625133543123.png)

### 关闭防火墙

操作服务器：所有服务器

```sh
systemctl stop firewalld ; systemctl disable firewalld
```

### 关闭selinux

修改配置文件，替换enfrcing为disabled。

```sh
sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
```

<font color="red">重启服务器</font>并执行

```sh
getenforce
```

### 关闭交换分区

提高效率

目的：防止启动k8s失败。

<font color="green">操作服务器：master1、master2、master3、node</font>

```sh
vi /etc/fstab
```

注释掉带swap那一行数据。

![image-20220625134941574](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625134941574.png)

<font color="red">重启服务器</font>并执行

```
free -m
```

修改前和修改后对比

![image-20220625135345454](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625135345454.png)

修改后

![image-20220625135323080](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625135323080.png)

### 修改内核参数

<font color="green">操作服务器：master1、master2、master3、node</font>

步骤：

加载br_netfilter模块，如果不开启，会在sysctl那一步提示错误。

```sh
modprobe br_netfilter
```

验证模块是否加载成功

```sh
lsmod |grep br_netfilter
```

修改内核参数

```sh
cat > /etc/sysctl.d/k8s.conf <<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF
```

使刚才修改的内核参数生效, -p  从指定的文件加载系统参数，如不指定即从/etc/sysctl.conf中加载。

```sh
sysctl -p /etc/sysctl.d/k8s.conf 
```

##### 常见问题

###### 为啥开启net.bride？

解决docker infor提示警告

```sh
WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled
```

###### 为啥开启配置net.ipv4.ip_forward = 1？

出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。

要让Linux系统具有路由转发功能，需要配置一个Linux的内核参数net.ipv4.ip_forward。这个参数指定了Linux系统当前对路由转发功能的支持情况；其值为0时表示禁止进行IP转发；如果是1,则说明IP转发功能已经打开

### 配置阿里云repo源

<font color="green">操作服务器：master1、master2、master3、node,vip</font>

### 安装lrzsz

```
yum install lrzsz -y
```

作者ps:如果按照最开始的配置，同时执行安装可能会出现卡。

### 安装scp

```
yum install openssh-clients -y
```

### 备份基础repo源

```
mkdir /root/repo.bak
cd /etc/yum.repos.d/
mv * /root/repo.bak/
```

### 设置基础repo源

上传Centos-Base.repo到/etc/yum.repos.d目录。作者ps:这一章节我是用xftp上传文件

在master1上传完毕以后调用以下命令发送文件

```
scp CentOS-Base.repo master2:/etc/yum.repos.d/
scp CentOS-Base.repo master3:/etc/yum.repos.d/
scp CentOS-Base.repo node:/etc/yum.repos.d/
scp CentOS-Base.repo 192.168.2.132:/etc/yum.repos.d/
```

设置阿里云的docker的repo源，或者将附录里面的docker-ce.repo拷贝到指定目录

```sh
yum -y install yum-utils
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

### 检查repo源

在/etc/yum.repos.d目录下应该存在两个repo

![image-20220625142339351](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625142339351.png)

### 设置时间

安装ntp

```
yum install ntpdate -y
```

校时

```yum
ntpdate cn.pool.ntp.org
```

注意：这一步，有的镜像会存在问题,使用`ntpdate -d`可以看到 no data错误。自行网络搜索。

定时校验服务

```
crontab -e
```

追加内容

```
* */1 * * * /usr/sbin/ntpdate   cn.pool.ntp.org
```

重启服务

```
systemctl restart crond
```

### 安装iptables

如果用firewalld不习惯，可以安装iptables ，在xianchaomaster1、xianchaomaster2、xianchaomaster3、xianchaonode1上操作：

\#安装iptables

```
yum install iptables-services -y
```

\#禁用iptables

```
service iptables stop  && systemctl disable iptables
```

\#清空防火墙规则

```
iptables -F
```

### 开启ipvs

<font color="green">操作服务器：master1、master2、master3、node</font>

目的：ipvs 可以更快地重定向流量，并且在同步代理规则时具有更好的性能。(比较iptables而言)

步骤：

从`file/k8s安装所需文件/ipvs.modules`拷贝到`/etc/sysconfig/modules`，并执行

```ssh
chmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep ip_vs
```

1. 授予所有权限给拥有者，读和执行文件给其他人。

2. bash执行脚本

3. 检查结果，出现截图结果表示成功。

   ![image-20220625152949903](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220625152949903.png)

将该文件发送到其他节点并执行同样动作。

```sh
scp ipvs.modules master2:/etc/sysconfig/modules/
scp ipvs.modules master3:/etc/sysconfig/modules/
scp ipvs.modules node:/etc/sysconfig/modules/
```

使用ssh命令快速切换服务器并执行

```sh
chmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep ip_vs
```

### 安装基础环境

<font color="green">操作服务器：master1、master2、master3、node,vip</font>

```sh
yum install -y yum-utils device-mapper-persistent-data lvm2 wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel  python-devel epel-release openssh-server socat  ipvsadm conntrack ntpdate telnet rsync
```

### 安装docker-ce

<font color="green">操作服务器：master1、master2、master3、node</font>

控制节点可以不用安装docker。这里我选择安装上。

作者ps:如果DNS有问题可能会出现yum 404。

```sh
yum install docker-ce docker-ce-cli containerd.io -y 
systemctl start docker && systemctl enable docker.service && systemctl status docker
```

### 设置docker镜像加速

<font color="green">操作服务器：master1、master2、master3、node</font>

"exec-opts"：启动时候的额外参数(驱动)。

```sh
tee /etc/docker/daemon.json << 'EOF'
{
 "registry-mirrors":["https://rsbud4vc.mirror.aliyuncs.com","https://registry.docker-cn.com","https://docker.mirrors.ustc.edu.cn","https://dockerhub.azk8s.cn","http://hub-mirror.c.163.com","http://qtid6917.mirror.aliyuncs.com", "https://rncxm540.mirror.aliyuncs.com"],
  "exec-opts": ["native.cgroupdriver=systemd"]
} 
EOF
```

重启

```sh
systemctl daemon-reload
systemctl restart docker
systemctl status docker
```

ps:新装docker不会出现重启不了的问题。如果启动不了，检查配置

```sh
# 解决报错
vi /lib/systemd/system/docker.service
# 找到并删除下面这句话，保存退出，即可解决
# --exec-opt native.cgroupdriver=cgroupfs \

systemctl daemon-reload
systemctl restart docker
```

## 搭建etcd集群

<font color="green">操作服务器：master1、master2、master3</font>

### 配置基础目录

创建etcd根目录和证书存放目录。创建/data/work目录，

```sh
mkdir -p /etc/etcd/ssl
mkdir -p /data/work
```

### 安装签发证书工具cfssl

将附录里面的文件上传到/data/work目录，并授予执行权限。

```sh
cfssl-certinfo_linux-amd64  cfssljson_linux-amd64  cfssl_linux-amd64
```

授权语句

```sh
chmod +u /data/work/cfssl*
```

结果如下

![image-20220626195649791](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220626195649791.png)

将三个文件移动到/usr/local/bin目录下面，方便运行语句。

```sh
mv /data/work/cfssl* /usr/local/bin
```

重命名

```sh
[root@master1 bin]# mv cfssl_linux-amd64 cfssl
[root@master1 bin]# mv cfssl-certinfo_linux-amd64 cfssl-certinfo
[root@master1 bin]# mv cfssljson_linux-amd64 cfssljson
```

测试

```sh
[root@master1 bin]# cfssl version
Version: 1.2.0
Revision: dev
Runtime: go1.6
```

### 创建生成CA根证书

csr数字证书的核心，其实就是[非对称加密](https://so.csdn.net/so/search?q=非对称加密&spm=1001.2101.3001.7020)，也就是公私钥对加密。非对称加密之所以安全，前提条件是用户必须要保障私钥的安全。因此在用户向CA申请数字证书时，用户首先需要在自己的电脑中先产生一个公私钥对。私钥主要用于签名和解密，由用户自定义，只有用户自己知道；公钥用于签名验证和加密，可被多个用户共享。用户需要保管好自己的私钥，然后再把公钥和你的个人信息发送给CA机构，CA机构通过你的公钥和个人信息最终签发出数字证书。而CSR文件，其实就是包含了用户公钥和个人信息的一个数据文件。用户产生出这个CSR文件，再把这个CSR文件发送给CA，CA就会根据CSR中的内容来签发出数字证书。

##### 创建CA证书请求

ca-csr.json的作用： CA 证书签名请求（CSR）

```sh
vim /data/work/ca-csr.json
```

内容如下

```json
{
  "CN": "kubernetes",
  "key": {
      "algo": "rsa",
      "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Hubei",
      "L": "Wuhan",
      "O": "k8s",
      "OU": "system"
    }
  ],
  "ca": {
    "expiry": "87600h"
  }
}
```



###### 字段说明

“CN”：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；
“O”：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；
“C”: Country， 国家
“L”: Locality，地区，城市
“O”: Organization Name，组织名称，公司名称
“OU”: Organization Unit Name，组织单位名称，公司部门
“ST”: State，州，省

“CN”：Common Name，从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；
“O”：Organization，从证书中提取该字段作为请求用户所属的组 (Group)；

##### 生成CA证书和私钥

```sh
cfssl gencert -initca ca-csr.json  | cfssljson -bare ca
```

运行结果

```sh
[root@master1 work]# cfssl gencert -initca ca-csr.json  | cfssljson -bare ca
2022/06/26 20:16:50 [INFO] generating a new CA key and certificate from CSR
2022/06/26 20:16:50 [INFO] generate received request
2022/06/26 20:16:50 [INFO] received CSR
2022/06/26 20:16:50 [INFO] generating key: rsa-2048
2022/06/26 20:16:50 [INFO] encoded CSR
2022/06/26 20:16:50 [INFO] signed certificate with serial number 395962326770381162627940084300520515534025043700
```

```sh
生成ca.pem、ca.csr、ca-key.pem(CA私钥,需妥善保管)
```

### 生成默认CA配置

ca-config.json文件，会设置证书相关参数。

```sh
vim /data/work/ca-config.json
```

内容如下

```json
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
        "usages": [
          "signing",
          "key encipherment",
          "server auth",
          "client auth"
        ],
        "expiry": "87600h"
      }
    }
  }
}
```

注意：profiles里面的配置要和后面一致。

###### 字段说明

ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；
signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA:TRUE；
server auth：表示client可以用该 CA 对server提供的证书进行验证；
client auth：表示server可以用该CA对client提供的证书进行验证；



### 生成etcd server端证书

##### 创建etcd的CA请求

```sh
vim /data/work/etcd-csr.json
```

内容如下

```name
{
  "CN": "etcd",
  "hosts": [
    "127.0.0.1",
    "192.168.2.125",
    "192.168.2.126",
    "192.168.2.127",
    "192.168.2.128",
    "192.168.2.129",
    "192.168.2.130",
    "192.168.2.132"
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [{
    "C": "CN",
    "ST": "Hubei",
    "L": "Wuhan",
    "O": "k8s",
    "OU": "system"
  }]
} 
```

内容描述：

- CN:表示软件机构
- host:预留了几个ip作为后期扩容，工作节点不需要加入。
- key:使用了rsa算法，长度2048
- name:生成策略配置

##### 生成证书和私钥

使用CA的证书和公钥，以ca-config里面的kubernetes设置证书的配置。

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson  -bare etcd
```

-  -ca=ca.pem CA生成出来的文件 
- -ca-key=ca-key.pem CA生成出来的文件
- -config=ca-config.json创建的配置文件
- -profile=kubernetes 获取配置文件里面的配置
- etcd-csr.json 指定etcd证书的配置请求

```sh
[root@master1 work]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson  -bare etcd
2022/06/26 20:28:55 [INFO] generate received request
2022/06/26 20:28:55 [INFO] received CSR
2022/06/26 20:28:55 [INFO] generating key: rsa-2048
2022/06/26 20:28:55 [INFO] encoded CSR
2022/06/26 20:28:55 [INFO] signed certificate with serial number 136421659044390547898379329245311623656058791942
2022/06/26 20:28:55 [WARNING] This certificate lacks a "hosts" field. This makes it unsuitable for
websites. For more information see the Baseline Requirements for the Issuance and Management
of Publicly-Trusted Certificates, v.1.1.6, from the CA/Browser Forum (https://cabforum.org);
specifically, section 10.2.3 ("Information Requirements").
```

检查文件生成情况

```sh
ls etcd*.pem
```

证书情况，公钥和私钥都在。

etcd.pem：公钥，etcd-key.pem：私钥

```sh
[root@master1 work]# ls etcd*.pem
etcd-key.pem  etcd.pem
```

### 部署etcd集群

上传`etcd-v3.4.13-linux-amd64.tar.gz`压缩包，解压压缩包。其中最重要就是etcd和etcdctl

```sh
[root@master1 etcd-v3.4.13-linux-amd64]# ll
总用量 40568
drwxr-xr-x 14 630384594 600260513     4096 8月  25 2020 Documentation
-rwxr-xr-x  1 630384594 600260513 23847904 8月  25 2020 etcd
-rwxr-xr-x  1 630384594 600260513 17620576 8月  25 2020 etcdctl
-rw-r--r--  1 630384594 600260513    43094 8月  25 2020 README-etcdctl.md
-rw-r--r--  1 630384594 600260513     8431 8月  25 2020 README.md
-rw-r--r--  1 630384594 600260513     7855 8月  25 2020 READMEv2-etcdctl.md

```

并移动到`/usr/local/bin`

```sh
tar -xf /data/work/etcd-v3.4.13-linux-amd64.tar.gz
cp -p /data/work/etcd-v3.4.13-linux-amd64/etcd* /usr/local/bin
ls /usr/local/bin/etcd*
```

并将关键文件发送到其他控制节点

```sh
scp -r  /data/work/etcd-v3.4.13-linux-amd64/etcd* master2:/usr/local/bin/
scp -r  /data/work/etcd-v3.4.13-linux-amd64/etcd* master3:/usr/local/bin/
```

过程:

```sh
[root@master1 etcd-v3.4.13-linux-amd64]# scp -r  /data/work/etcd-v3.4.13-linux-amd64/etcd* master2:/usr/local/bin/
etcd                                                                                          100%   23MB  51.0MB/s   00:00    
etcdctl                                                                                       100%   17MB  70.0MB/s   00:00    
您在 /var/spool/mail/root 中有新邮件
[root@master1 etcd-v3.4.13-linux-amd64]# scp -r  /data/work/etcd-v3.4.13-linux-amd64/etcd* master3:/usr/local/bin/
etcd                                                                                          100%   23MB  44.4MB/s   00:00    
etcdctl                                                                                       100%   17MB  63.5MB/s   00:00 
```

创建etcd数据库的配置文件

```
vim /data/work/etcd.conf 
```

内容以及配置描述：

```sh
#[Member]
#节点名称，集群中唯一
ETCD_NAME="etcd1"
#数据目录
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
#集群通信监听地址
ETCD_LISTEN_PEER_URLS="https://192.168.2.128:2380"
#客户端访问监听地址
ETCD_LISTEN_CLIENT_URLS="https://192.168.2.128:2379,http://127.0.0.1:2379"
#[Clustering]
#集群通告地址
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.2.128:2380"
#客户端通告地址
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.2.128:2379"
#集群节点地址,etcd1是ETCD_NAME，且是https协议
ETCD_INITIAL_CLUSTER="etcd1=https://192.168.2.128:2380,etcd2=https://192.168.2.129:2380,etcd3=https://192.168.2.130:2380"
#集群Token
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster-test"
#加入集群的当前状态，new是新集群，existing表示加入已有集群
ETCD_INITIAL_CLUSTER_STATE="new"
```

### 创建etcd服务器

创建服务，方便服务自启和监听状态

```sh
vim etcd.service
```

```sh
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
 
[Service]
Type=notify
EnvironmentFile=-/etc/etcd/etcd.conf
WorkingDirectory=/var/lib/etcd/
ExecStart=/usr/local/bin/etcd \
  --cert-file=/etc/etcd/ssl/etcd.pem \
  --key-file=/etc/etcd/ssl/etcd-key.pem \
  --trusted-ca-file=/etc/etcd/ssl/ca.pem \
  --peer-cert-file=/etc/etcd/ssl/etcd.pem \
  --peer-key-file=/etc/etcd/ssl/etcd-key.pem \
  --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \
  --peer-client-cert-auth \
  --client-cert-auth
Restart=on-failure
RestartSec=5
LimitNOFILE=65536
 
[Install]
WantedBy=multi-user.target
```

参数描述：

- 1.EnvironmentFile即配置文件的位置，注意“-”不能少

将pem文件拷贝到/etc/etcd/ssl/

```sh
[root@master1 work]# ls /data/work/*.pem
ca-key.pem  ca.pem  etcd-key.pem  etcd.pem
```

拷贝文件到`/etc/etcd/ssl/`

```sh
cp /data/work/*.pem /etc/etcd/ssl/
```

检查结果

```
[root@master1 work]# ls /etc/etcd/ssl/
ca-key.pem  ca.pem  etcd-key.pem  etcd.pem
```

```
cp /data/work/etcd.conf /etc/etcd/
cp /data/work/etcd.service /usr/lib/systemd/system/
```

<font color="red">将配置文件发送到其他节点</font>

拷贝etcd配置文件

拷贝etcd和ca证书

拷贝etcd服务

```sh
for i in master2 master3;do rsync -vaz etcd.conf $i:/etc/etcd/;done
for i in master2 master3;do rsync -vaz etcd*.pem ca*.pem $i:/etc/etcd/ssl/;done
for i in master2 master3;do rsync -vaz etcd.service $i:/usr/lib/systemd/system/;done
```

创建数据库存储位置，参考service配置里面的文件夹。

```sh
[root@master1 work]# mkdir -p /var/lib/etcd/default.etcd
[root@master2 work]# mkdir -p /var/lib/etcd/default.etcd
[root@master3 work]# mkdir -p /var/lib/etcd/default.etcd
```

启动etcd节点

作者ps:启动第一个节点master1,会卡住，切换窗口启动其他节点就会成功。

```sh
systemctl daemon-reload
systemctl enable etcd
systemctl start etcd
```

查看状态

```sh
systemctl status etcd.service
```

![image-20220626213232720](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220626213232720.png)

查看etcd集群状态

```
/usr/local/bin/etcdctl --write-out=table --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem --endpoints=https://192.168.2.128:2379,https://192.168.2.129:2379,https://192.168.2.130:2379  endpoint health
```

出现下图即表示成功

![image-20220626213908672](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220626213908672.png)

## 安装k8s组件

下载安装包https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/

解压安装包以后，将控制节点需要的组件：apiserver,controller-manager,scheduler,kubectl

```sh
tar zxvf /data/work/kubernetes-server-linux-amd64.tar.gz
cd /data/work/kubernetes/server/bin/
cp kube-apiserver kube-controller-manager kube-scheduler kubectl /usr/local/bin/
```

检查结果

```sh
[root@master1 bin]# ls /usr/local/bin/kube-*
/usr/local/bin/kube-apiserver  /usr/local/bin/kube-controller-manager  /usr/local/bin/kube-scheduler
```

将将上述组件发送到其他的控制节点（master2,master3）

```sh
rsync -vaz kube-apiserver kube-controller-manager kube-scheduler kubectl master2:/usr/local/bin/
rsync -vaz kube-apiserver kube-controller-manager kube-scheduler kubectl master3:/usr/local/bin/
```

工作节点需要kubelet和kube-proxy。在/data/work/kubernetes/server/bin执行

```
scp kubelet kube-proxy node:/usr/local/bin/
```

退回/data/work

```sh
cd /data/work/
```

创建k8s软件目录和证书目录以及日志目录。

```
mkdir -p /etc/kubernetes/ssl
mkdir -p /var/log/kubernetes
```

### 安装apiserver组件

启动TLS Bootstrapping 机制

Master apiserver启用TLS认证后，每个节点的 kubelet 组件都要使用由 apiserver 使用的 CA 签发的有效证书才能与 apiserver 通讯，当Node节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。

为了简化流程，Kubernetes引入了TLS bootstraping机制来自动颁发客户端证书，<font color="red">kubelet会以一个低权限用户自动向apiserver申请证书，kubelet的证书由apiserver动态签署</font>。

Bootstrap 是很多系统中都存在的程序，比如 Linux 的bootstrap，bootstrap 一般都是作为预先配置在开启或者系统启动的时候加载，这可以用来生成一个指定环境。Kubernetes 的 kubelet 在启动时同样可以加载一个这样的配置文件，这个文件的内容类似如下形式：

```yaml
apiVersion: v1
clusters: null
contexts:
- context:
    cluster: kubernetes
    user: kubelet-bootstrap
  name: default
current-context: default
kind: Config
preferences: {}
users:
- name: kubelet-bootstrap
  user: {}
```

#### 原理讲解

##### TLS bootstrapping 具体引导过程 

1. TLS 作用 

   TLS 的作用就是对通讯加密，<font color="red">防止中间人窃听</font>；同时如果证书不信任的话根本就无法与 apiserver 建立连接，更不用提有没有权限向apiserver请求指定内容。

2. RBAC 作用 

   当 TLS 解决了通讯问题后，那么权限问题就应由 RBAC 解决(可以使用其他权限模型，如 ABAC)；RBAC 中规定了一个用户或者用户组(subject)具有请求哪些 api 的权限；在配合 TLS 加密的时候，实际上 apiserver 读取客户端证书的<font color="red"> CN 字段作为用户名，读取 O字段作为用户组</font>.

以上说明：第一，想要与 apiserver 通讯就必须采用由 apiserver CA 签发的证书，这样才能形成信任关系，建立 TLS 连接；第二，可以通过证书的 CN、O 字段来提供 RBAC 所需的用户与用户组。

##### kubelet 首次启动流程 

TLS bootstrapping 功能是让 kubelet 组件去 apiserver 申请证书，然后用于连接 apiserver；那么第一次启动时没有证书如何连接 apiserver ?

在<font color="red">apiserver </font>配置中指定了一个<font color="red"> token.csv</font> 文件，该文件中是一个<font color="red">预设的用户配置</font>；同时该用户的Token 和由apiserver 的 CA签发的用户被写入了 <font color="red">kubelet</font>所使用的<font color="red"> bootstrap.kubeconfig</font> 配置文件中；这样在首次请求时，kubelet 使用 bootstrap.kubeconfig 中被 apiserver CA 签发证书时信任的用户来与 apiserver 建立 TLS 通讯，使用 bootstrap.kubeconfig 中的用户 Token 来向 apiserver 声明自己的 RBAC 授权身份。

token.csv格式:token,用户名，id，用户组

```sh
3940fd7fbb391d1b4d861ad17a1f0613,kubelet-bootstrap,10001,"system:kubelet-bootstrap"
```

首次启动时，可能与遇到 kubelet 报 401 无权访问 apiserver 的错误；

这是因为在默认情况下，kubelet 通过 bootstrap.kubeconfig 中的预设用户 Token 声明了自己的身份，然后创建 CSR 请求；但是不要忘记这个用户在我们<font color="red">不处理的情况下他没任何权限的</font>，包括创建 CSR 请求；所以需要创建一个 ClusterRoleBinding，将<font color="red">预设用户 kubelet-bootstrap 与内置的 ClusterRole system:node-bootstrapper </font>绑定到一起，使其能够发起 CSR 请求。稍后安装kubelet的时候演示。

#### 步骤

##### 创建token.csv文件

```sh
cat > token.csv << EOF
$(head -c 16 /dev/urandom | od -An -t x | tr -d ' '),kubelet-bootstrap,10001,"system:kubelet-bootstrap"
EOF
```

格式：token，用户名，UID，用户组

##### 创建apiserver的证书

创建证书请求文件`kube-apiserver-csr.json`

```sh
vim kube-apiserver-csr.json
```

内容如下

```
{
  "CN": "kubernetes",
  "hosts": [
    "127.0.0.1",
    "192.168.2.125",
    "192.168.2.126",
    "192.168.2.127",
    "192.168.2.128",
    "192.168.2.129",
    "192.168.2.130",
    "192.168.2.131",
    "192.168.2.132",
    "10.255.0.1",
    "kubernetes",
    "kubernetes.default",
    "kubernetes.default.svc",
    "kubernetes.default.svc.cluster",
    "kubernetes.default.svc.cluster.local"
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Hubei",
      "L": "Wuhan",
      "O": "k8s",
      "OU": "system"
    }
  ]
}
```

\#注： 如果 hosts 字段不为空则需要指定授权使用该证书的 IP 或域名列表。 由于该证书后续被 kubernetes master 集群使用，需要将master节点的IP都填上，同时还需要填写 service 网络的首个IP。(一般是 kube-apiserver 指定的 service-cluster-ip-range 网段的第一个IP，如 <font color="red">10.255.0.1</font>)

注意：包括控制节点和工作节点。

生成公钥私钥

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-apiserver-csr.json | cfssljson -bare kube-apiserver
```

##### 创建api-server的配置文件

启动apiserver配置,。

```
KUBE_APISERVER_OPTS="--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \
  --anonymous-auth=false \
  --bind-address=192.168.2.128 \
  --secure-port=6443 \
  --advertise-address=192.168.2.128 \
  --insecure-port=0 \
  --authorization-mode=Node,RBAC \
  --runtime-config=api/all=true \
  --enable-bootstrap-token-auth \
  --service-cluster-ip-range=10.255.0.0/16 \
  --token-auth-file=/etc/kubernetes/token.csv \
  --service-node-port-range=30000-50000 \
  --tls-cert-file=/etc/kubernetes/ssl/kube-apiserver.pem  \
  --tls-private-key-file=/etc/kubernetes/ssl/kube-apiserver-key.pem \
  --client-ca-file=/etc/kubernetes/ssl/ca.pem \
  --kubelet-client-certificate=/etc/kubernetes/ssl/kube-apiserver.pem \
  --kubelet-client-key=/etc/kubernetes/ssl/kube-apiserver-key.pem \
  --service-account-key-file=/etc/kubernetes/ssl/ca-key.pem \
  --service-account-signing-key-file=/etc/kubernetes/ssl/ca-key.pem  \
  --service-account-issuer=https://kubernetes.default.svc.cluster.local \
  --etcd-cafile=/etc/etcd/ssl/ca.pem \
  --etcd-certfile=/etc/etcd/ssl/etcd.pem \
  --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem \
  --etcd-servers=https://192.168.2.128:2379,https://192.168.2.129:2379,https://192.168.2.130:2379 \
  --enable-swagger-ui=true \
  --allow-privileged=true \
  --apiserver-count=3 \
  --audit-log-maxage=30 \
  --audit-log-maxbackup=3 \
  --audit-log-maxsize=100 \
  --audit-log-path=/var/log/kube-apiserver-audit.log \
  --event-ttl=1h \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=4"
```

\#注： 

--logtostderr：启用日志 

--v：日志等级

--log-dir：日志目录 

--etcd-servers：etcd集群地址 

--bind-address：监听地址 

--secure-port：https安全端口 

--advertise-address：集群通告地址 

--allow-privileged：启用授权 

--service-cluster-ip-range：Service虚拟IP地址段

--enable-admission-plugins：准入控制模块 

--authorization-mode：认证授权，启用RBAC授权和节点自管理 

--enable-bootstrap-token-auth：启用TLS bootstrap机制

--token-auth-file：bootstrap token文件 

--service-node-port-range：Service nodeport类型默认分配端口范围 

--kubelet-client-xxx：apiserver访问kubelet客户端证书

--tls-xxx-file：apiserver https证书 

--etcd-xxxfile：连接Etcd集群证书 

-audit-log-xxx：审计日志

##### 创建服务

```
cat > kube-apiserver.service << EOF
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=etcd.service
Wants=etcd.service
[Service]
EnvironmentFile=-/etc/kubernetes/kube-apiserver.conf
ExecStart=/usr/local/bin/kube-apiserver $KUBE_APISERVER_OPTS
Restart=on-failure
RestartSec=5
Type=notify
LimitNOFILE=65536
[Install]
WantedBy=multi-user.target
EOF
```

##### 移动文件

master1节点

```sh
#CA公钥私钥
cp ca*.pem /etc/kubernetes/ssl
#apiserver公钥私钥
cp kube-apiserver*.pem /etc/kubernetes/ssl/
#apiserver的第一次连接所需默认配置
cp token.csv /etc/kubernetes/
#apiserver启动配置
cp kube-apiserver.conf /etc/kubernetes/
#apiserver服务
cp kube-apiserver.service /usr/lib/systemd/system/
```

master2节点

```sh
#apiserver默认配置
rsync -vaz token.csv master2:/etc/kubernetes/
#apiserver的证书
rsync -vaz kube-apiserver*.pem master2:/etc/kubernetes/ssl/
#ca证书
rsync -vaz ca*.pem master2:/etc/kubernetes/ssl/
#apiserver配置
rsync -vaz kube-apiserver.conf master2:/etc/kubernetes/
#服务
rsync -vaz kube-apiserver.service master2:/usr/lib/systemd/system/
```

作者ps:一定要注意是否发送成功。

错误例子

```sh
[root@master1 work]# rsync -vaz kube-apiserver*.pem master3:/etc/kubernetes/ssl/
sending incremental file list
rsync: mkdir "/etc/kubernetes/ssl" failed: No such file or directory (2)
rsync error: error in file IO (code 11) at main.c(657) [Receiver=3.1.2]
[root@master1 work]# rsync -vaz kube-apiserver*.pem master2/etc/kubernetes/ssl/
sending incremental file list
rsync: mkdir "/data/work/master2/etc/kubernetes/ssl" failed: No such file or directory (2)
rsync error: error in file IO (code 11) at main.c(657) [Receiver=3.1.2]
```

master3节点

```sh
#apiserver默认配置
rsync -vaz token.csv master3:/etc/kubernetes/
#apiserver的证书
rsync -vaz kube-apiserver*.pem master3:/etc/kubernetes/ssl/
#ca证书
rsync -vaz ca*.pem master3:/etc/kubernetes/ssl/
#apiserver配置
rsync -vaz kube-apiserver.conf master3:/etc/kubernetes/
#服务
rsync -vaz kube-apiserver.service master3:/usr/lib/systemd/system/
```

修改kube-apiserver.conf里面的ip为所在节点ip。（master2,master3）

![image-20220628220859320](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220628220859320.png)

![image-20220628221002102](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220628221002102.png)

#### 测试

启动服务

```
systemctl daemon-reload
systemctl enable kube-apiserver
systemctl start kube-apiserver
```

哦豁出错了~

使用下面语句排错

```sh
cat /var/log/messages|grep kube-apiserver|grep -i error
```

```sh
[root@master1 work]# cat /var/log/messages|grep kube-apiserver|grep -i error
Jun 28 22:10:52 master1 kube-apiserver: Error: [--etcd-servers must be specified, service-account-issuer is a required flag, --service-account-signing-key-file and --service-account-issuer are required flags]
Jun 28 22:10:57 master1 kube-apiserver: Error: [--etcd-servers must be specified, service-account-issuer is a required flag, --service-account-signing-key-file and --service-account-issuer are required flags]
Jun 28 22:11:02 master1 kube-apiserver: Error: [--etcd-servers must be specified, service-account-issuer is a required flag, --service-account-signing-key-file and --service-account-issuer are required flags]
Jun 28 22:11:08 master1 kube-apiserver: Error: [--etcd-servers must be specified, service-account-issuer is a required flag, --service-account-signing-key-file and --service-account-issuer are required flags]
Jun 28 22:11:13 master1 kube-apiserver: Error: [--etcd-servers must be specified, service-account-issuer is a required flag, --service-account-signing-key-file and --service-account-issuer are required flags]
```

或者使用

```sh
 journalctl -xe -u kube-apiserver | more
```

查看错误前后是否存在其他错误，如果没有即可确定配置文件问题。

这里我的问题，我直接使用/usr/local/bin/kube-apiserver 加参数没问题。但是服务有问题。

通过这一步，即可确定配置未生效。

![image-20220628233653252](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220628233653252.png)

重写修改即可。

![image-20220628233529205](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220628233529205.png)

成功截图

![image-20220628234216455](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220628234216455.png)

请求测试

```
curl --insecure https://192.168.2.128:6443/
curl --insecure https://192.168.2.129:6443/
curl --insecure https://192.168.2.130:6443/
```

提示

```json
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {
    
  },
  "status": "Failure",
  "message": "Unauthorized",
  "reason": "Unauthorized",
  "code": 401
}
```

这就是前文说到的，虽然创建了用户，并绑定了组。但是没有为用户绑定角色，所以没有权限。

### 安装kubectl组件

Kubectl是客户端工具，操作k8s资源的，如增删改查等。

Kubectl操作资源的时候，怎么知道连接到哪个集群，需要一个文件/etc/kubernetes/admin.conf，kubectl会根据这个文件的配置，去访问k8s资源。/etc/kubernetes/admin.con文件记录了访问的k8s集群，和用到的证书。

可以设置一个环境变量KUBECONFIG

```
export KUBECONFIG=/etc/kubernetes/admin.conf
```

这样在操作kubectl，就会自动加载KUBECONFIG来操作要管理哪个集群的k8s资源了

也可以按照下面方法，这个是在kubeadm初始化k8s的时候会告诉我们要用的一个方法

```sh
cp /etc/kubernetes/admin.conf /root/.kube/config
```

这样我们在执行kubectl，就会加载/root/.kube/config文件，去操作k8s资源了

如果设置了KUBECONFIG，那就会先找到KUBECONFIG去操作k8s，如果没有KUBECONFIG变量，那就会使用/root/.kube/config文件决定管理哪个k8s集群的资源。

#### 步骤

##### 创建admin用户

```
vim /data/work/admin-csr.json 
```

内容如下

```sh
{
  "CN": "admin",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Hubei",
      "L": "Wuhan",
      "O": "system:masters",             
      "OU": "system"
    }
  ]
}
```

CN：是用户名

O：是用户组

后续 kube-apiserver 使用 RBAC 对客户端(如 kubelet、kube-proxy、Pod)请求进行授权； kube-apiserver 预定义了一些 RBAC 使用的 RoleBindings，如<font color="red"> cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定</font>，该 Role 授予了调用kube-apiserver 的所有 API的权限； O指定该证书的 Group 为 system:masters，kubelet 使用该证书访问 kube-apiserver 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 system:masters，所以被授予访问所有 API 的权限； 

注： 这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group； "O": "system:masters", 必须是system:masters，否则后面kubectl create clusterrolebinding报错。

admin证书配置为system:masters 在集群内部cluster-admin的clusterrolebinding将system:masters组和cluster-admin clusterrole绑定在一起。

##### 生成admin证书

在/data/work里面执行

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
```

移动

```sh
cp admin*.pem /etc/kubernetes/ssl/
```

##### 创建kube.conf配置文件

###### 设置集群参数

设置api-server节点ip。

```sh
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.2.128:6443 --kubeconfig=kube.config
```

###### 设置用户

设置用户为admin,admin的证书

```sh
kubectl config set-credentials admin --client-certificate=admin.pem --client-key=admin-key.pem --embed-certs=true --kubeconfig=kube.config
```

###### 设置上下文

设置访问的集群和用户为一组。

```sh
 kubectl config set-context kubernetes --cluster=kubernetes --user=admin --kubeconfig=kube.config
```

###### 设置当前上下文

除了设置上下文，还有指定当前上下文是kubernetes

```sh
kubectl config use-context kubernetes --kubeconfig=kube.config
```

###### kube.conf移动到~/.kube/config

将kube.conf移动指定目录才可以激活配置

```sh
mkdir -p ~/.kube/config
cp kube.config ~/.kube/config
```

 只有这一步成功了，才能够执行下一步。

##### 授权kubernetes证书访问kubelet api权限

```sh
kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes
```

##### 测试

看集群情况

```sh
kubectl cluster-info
```

组件情况

```sh
kubectl get componentstatuses
```

结果

```
[root@master1 work]# kubectl cluster-info
Kubernetes control plane is running at https://192.168.2.128:6443

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
您在 /var/spool/mail/root 中有新邮件
[root@master1 work]# kubectl get componentstatuses
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS      MESSAGE                                                                                       ERROR
scheduler            Unhealthy   Get "http://127.0.0.1:10251/healthz": dial tcp 127.0.0.1:10251: connect: connection refused   
controller-manager   Unhealthy   Get "http://127.0.0.1:10252/healthz": dial tcp 127.0.0.1:10252: connect: connection refused   
etcd-2               Healthy     {"health":"true"}                                                                             
etcd-1               Healthy     {"health":"true"}                                                                             
etcd-0               Healthy     {"health":"true"}   
```

##### 同步其他节点

```
[root@master2 ~]# mkdir /root/.kube/
[root@master3 ~]#  mkdir /root/.kube/
```

发送配置到指定目录

```bash
rsync -vaz /root/.kube/config master2:/root/.kube/
rsync -vaz /root/.kube/config master3:/root/.kube/
```

并测试。

##### 设置kubectl自动补全

```sh
yum install -y bash-completion
```

没有设置前

![image-20220630214317063](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220630214317063.png)

```bash
source <(kubectl completion bash) # 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。
echo "source <(kubectl completion bash)" >> ~/.bashrc # 在您的 bash shell 中永久的添加自动补全
```

![image-20220630214413546](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220630214413546.png)

适配于更多情况

```bash
[root@xianchaomaster1 work]# yum install -y bash-completion
[root@xianchaomaster1 work]# source /usr/share/bash-completion/bash_completion
[root@xianchaomaster1 work]# source <(kubectl completion bash)
[root@xianchaomaster1 work]# kubectl completion bash > ~/.kube/completion.bash.inc
[root@xianchaomaster1 work]# source '/root/.kube/completion.bash.inc'
[root@xianchaomaster1 work]# source $HOME/.bash_profile
```

### 安装kube-controller-manager

#### 创建kuber-controller-manager证书

```bash
vim kube-controller-manager-csr.json
```

不包括工作节点

```
{
	"CN": "system:kube-controller-manager",
	"key": {
		"algo": "rsa",
		"size": 2048
	},
	"hosts": [
		"127.0.0.1",
		"192.168.2.125",
		"192.168.2.126",
		"192.168.2.127",
		"192.168.2.128",
		"192.168.2.129",
		"192.168.2.130",
		"192.168.2.132"
	],
	"names": [{
		"C": "CN",
		"ST": "Hubei",
		"L": "Wuhan",
		"O": "system:kube-controller-manager",
		"OU": "system"
	}]
}
```

 hosts 列表包含所有 kube-controller-manager 节点 IP； 

CN 为 system:kube-controller-manager、O 为 system:kube-controller-manager，kubernetes 内置的 ClusterRoleBindings system:kube-controller-manager 赋予 kube-controller-manager 工作所需的权限

生成证书

```
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager
```

#### 创建kube-controller-manager.kubeconfig

#### 指定k8s集群里面的apiserver

```bash
 kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.2.128:6443 --kubeconfig=kube-controller-manager.kubeconfig
```

#### 设置客户端认证

```bash
kubectl config set-credentials system:kube-controller-manager --client-certificate=kube-controller-manager.pem --client-key=kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig
```

#### 设置上下文

```sh
kubectl config set-context system:kube-controller-manager --cluster=kubernetes --user=system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig
```

#### 设置当前上下文

```sh
kubectl config use-context system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig
```

#### 设置kube-controller-manager启动配置

```
vim kube-controller-manager.conf
```

默认bind-address是127.0.0.1

```sh
KUBE_CONTROLLER_MANAGER_OPTS="--port=0 \
  --secure-port=10252 \
  --bind-address=127.0.0.1 \
  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \
  --service-cluster-ip-range=10.255.0.0/16 \
  --cluster-name=kubernetes \
  --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem \
  --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem \
  --allocate-node-cidrs=true \
  --cluster-cidr=10.0.0.0/16 \
  --experimental-cluster-signing-duration=87600h \
  --root-ca-file=/etc/kubernetes/ssl/ca.pem \
  --service-account-private-key-file=/etc/kubernetes/ssl/ca-key.pem \
  --leader-elect=true \
  --feature-gates=RotateKubeletServerCertificate=true \
  --controllers=*,bootstrapsigner,tokencleaner \
  --horizontal-pod-autoscaler-use-rest-clients=true \
  --horizontal-pod-autoscaler-sync-period=10s \
  --tls-cert-file=/etc/kubernetes/ssl/kube-controller-manager.pem \
  --tls-private-key-file=/etc/kubernetes/ssl/kube-controller-manager-key.pem \
  --use-service-account-credentials=true \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2"
```

#### 创建服务

```sh
vim kube-controller-manager.service 
```

内容

```
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes
[Service]
EnvironmentFile=-/etc/kubernetes/kube-controller-manager.conf
ExecStart=/usr/local/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS
Restart=on-failure
RestartSec=5
[Install]
WantedBy=multi-user.target
```

#### 移动文件

```sh
#移动证书
cp kube-controller-manager*.pem /etc/kubernetes/ssl/
#移动kubeconfig
cp kube-controller-manager.kubeconfig /etc/kubernetes/
#移动启动配置
cp kube-controller-manager.conf /etc/kubernetes/
#移动服务
cp kube-controller-manager.service /usr/lib/systemd/system/
```

#### 测试

```sh
systemctl start kube-controller-manager.service
systemctl enable kube-controller-manager.service
```

启动后检查启动配置

![image-20220630220145381](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220630220145381.png)

#### 发送相关文件到其他控制节点

```
rsync -vaz kube-controller-manager*.pem master2:/etc/kubernetes/ssl/
rsync -vaz kube-controller-manager*.pem master3:/etc/kubernetes/ssl/
rsync -vaz kube-controller-manager.kubeconfig kube-controller-manager.conf master2:/etc/kubernetes/
rsync -vaz kube-controller-manager.kubeconfig kube-controller-manager.conf master3:/etc/kubernetes/
rsync -vaz kube-controller-manager.service master2:/usr/lib/systemd/system/
rsync -vaz kube-controller-manager.service master3:/usr/lib/systemd/system/
```

并测试结果。

查看kubectl get cs。发现不健康状态。通过查找有人说注释“--port=0”。通过github查找到controller-manager这个状态已经废弃了。

![image-20220630221740032](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220630221740032.png)

### 安装kube-scheduler组件

#### 创建kuber-scheduler的证书申请

```sh
vim kube-scheduler-csr.json 
```

```
{
	"CN": "system:kube-scheduler",
	"key": {
		"algo": "rsa",
		"size": 2048
	},
	"hosts": [
		"127.0.0.1",
		"192.168.2.125",
		"192.168.2.126",
		"192.168.2.127",
		"192.168.2.128",
		"192.168.2.129",
		"192.168.2.130",
		"192.168.2.132"
	],
	"names": [{
		"C": "CN",
		"ST": "Hubei",
		"L": "Wuhan",
		"O": "system:kube-scheduler",
		"OU": "system"
	}]
}
```

hosts 列表包含所有 kube-scheduler 节点 IP； CN 为 system:kube-scheduler、O 为 system:kube-scheduler，kubernetes 内置的 ClusterRoleBindings system:kube-scheduler 将赋予 kube-scheduler 工作所需的权限。

#### 创建证书

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler
```

#### 生成kubeconfig文件

设置集群

```sh
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.2.128:6443 --kubeconfig=kube-scheduler.kubeconfig
```

设置凭证

```sh
kubectl config set-credentials system:kube-scheduler --client-certificate=kube-scheduler.pem --client-key=kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig
```

设置上下文

```sh
kubectl config set-context system:kube-scheduler --cluster=kubernetes --user=system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig
```

使用上下文

```sh
kubectl config use-context system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig
```

#### kube-scheduler启动项

```sh
KUBE_SCHEDULER_OPTS="--address=127.0.0.1 \
--kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \
--leader-elect=true \
--alsologtostderr=true \
--logtostderr=false \
--log-dir=/var/log/kubernetes \
--v=2"
```

#### 创建服务

```
vim kube-scheduler.service
```

```sh
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes
 
[Service]
EnvironmentFile=-/etc/kubernetes/kube-scheduler.conf
ExecStart=/usr/local/bin/kube-scheduler $KUBE_SCHEDULER_OPTS
Restart=on-failure
RestartSec=5
 
[Install]
WantedBy=multi-user.target
```

#### 移动配置文件

```sh
cp kube-scheduler*.pem /etc/kubernetes/ssl/
cp kube-scheduler.kubeconfig /etc/kubernetes/
cp kube-scheduler.conf /etc/kubernetes/
cp kube-scheduler.service /usr/lib/systemd/system/
```

#### 启动服务

```sh
systemctl daemon-reload
systemctl start kube-scheduler
systemctl status kube-scheduler
```

#### 配置其他节点

```sh
rsync -vaz kube-scheduler*.pem master2:/etc/kubernetes/ssl/
rsync -vaz kube-scheduler.kubeconfig kube-scheduler.conf master2:/etc/kubernetes/
rsync -vaz kube-scheduler.service master2:/usr/lib/systemd/system/

rsync -vaz kube-scheduler*.pem master3:/etc/kubernetes/ssl/
rsync -vaz kube-scheduler.kubeconfig kube-scheduler.conf master3:/etc/kubernetes/
rsync -vaz kube-scheduler.service master3:/usr/lib/systemd/system/
```

安装

### kubelet组件

每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server监听Pod信息，从而对Node机器上的POD进行管理，如创建、删除、更新Pod

```
cd /data/work/
```

设置第一次连接token

```
BOOTSTRAP_TOKEN=$(awk -F "," '{print $1}' /etc/kubernetes/token.csv)
```

#### 配置kubeconfig

设置集群

```sh
 kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.2.128:6443 --kubeconfig=kubelet-bootstrap.kubeconfig
```

设置凭证

```sh
kubectl config set-credentials kubelet-bootstrap --token=${BOOTSTRAP_TOKEN} --kubeconfig=kubelet-bootstrap.kubeconfig
```

设置上下文

```sh
kubectl config set-context default --cluster=kubernetes --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig
```

使用上下文

```sh
 kubectl config use-context default --kubeconfig=kubelet-bootstrap.kubeconfig
```

设置权限

```sh
kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap
```



```
vim kubelet.json
```

```json
{
  "kind": "KubeletConfiguration",
  "apiVersion": "kubelet.config.k8s.io/v1beta1",
  "authentication": {
    "x509": {
      "clientCAFile": "/etc/kubernetes/ssl/ca.pem"
    },
    "webhook": {
      "enabled": true,
      "cacheTTL": "2m0s"
    },
    "anonymous": {
      "enabled": false
    }
  },
  "authorization": {
    "mode": "Webhook",
    "webhook": {
      "cacheAuthorizedTTL": "5m0s",
      "cacheUnauthorizedTTL": "30s"
    }
  },
  "address": "192.168.2.131",
  "port": 10250,
  "readOnlyPort": 10255,
  "cgroupDriver": "systemd",
  "hairpinMode": "promiscuous-bridge",
  "serializeImagePulls": false,
  "featureGates": {
    "RotateKubeletClientCertificate": true,
    "RotateKubeletServerCertificate": true
  },
  "clusterDomain": "cluster.local.",
  "clusterDNS": ["10.255.0.2"]
}

```

#### 创建证书

创建服务

```
vim kubelet.service
```

```sh
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=docker.service
Requires=docker.service
[Service]
WorkingDirectory=/var/lib/kubelet
ExecStart=/usr/local/bin/kubelet \
  --bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \
  --cert-dir=/etc/kubernetes/ssl \
  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \
  --config=/etc/kubernetes/kubelet.json \
  --network-plugin=cni \
  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2 \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2
Restart=on-failure
RestartSec=5
 
[Install]
WantedBy=multi-user.target
```

```
#注： –hostname-override：显示名称，集群中唯一 
–network-plugin：启用CNI 
–kubeconfig：空路径，会自动生成，后面用于连接apiserver 
–bootstrap-kubeconfig：首次启动向apiserver申请证书
–config：配置参数文件 
–cert-dir：kubelet证书生成目录 
–pod-infra-container-image：管理Pod网络容器的镜像
```

#### 移动到工作节点

创建kubernetes根路径和证书路径

```sh
[root@master1 ~]# ssh node 
Last login: Sat Jul  2 14:10:48 2022 from master3
[root@node ~]#  mkdir -p /etc/kubernetes/ssl/
```

发送必要文件

```sh
scp kubelet-bootstrap.kubeconfig kubelet.json node:/etc/kubernetes/
scp  ca.pem node:/etc/kubernetes/ssl/
scp  kubelet.service node:/usr/lib/systemd/system/
```

创建必要文件夹

```sh
[root@master1 kubernetes]# ssh node 
Last login: Sat Jul  2 14:14:19 2022 from master1
[root@node ~]# mkdir /var/lib/kubelet
[root@node ~]# mkdir /var/log/kubernetes
```

#### 启动服务

```sh
[root@node ~]# systemctl daemon-reload
[root@node ~]# systemctl enable kubelet
[root@node ~]# systemctl start kubelet
[root@node ~]#  systemctl status kubelet
```

#### 测试

执行如下命令可以看到一个worker节点发送了一个 CSR 请求

```sh
kubectl get csr
```

结果

Pending：待处理

```sh
[root@master1 kubernetes]# kubectl get csr
NAME                                                   AGE   SIGNERNAME                                    REQUESTOR           CONDITION
node-csr-dyan0SovgWxlR2ljdUp2n_TAFZJ--aU2aiXSESAd628   42s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending
```

approve：批准

```sh
kubectl certificate approve node-csr-dyan0SovgWxlR2ljdUp2n_TAFZJ--aU2aiXSESAd628
```

Approved：已经批准，issued：已发布。

```sh
[root@master1 kubernetes]# kubectl get csr
NAME                                                   AGE     SIGNERNAME                                    REQUESTOR           CONDITION
node-csr-dyan0SovgWxlR2ljdUp2n_TAFZJ--aU2aiXSESAd628   3m13s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap  Approved,Issued
```

使用kubectl查看节点状态

```sh
kubectl get nodes
```

status是notReay，这是因为还没安装网络插件，无法查看node状态。

```sh
[root@master1 kubernetes]# kubectl get nodes
NAME   STATUS     ROLES    AGE   VERSION
node   NotReady   <none>   2m    v1.20.7
```

### 部署kube-proxy组件

#### 证书请求

```sh
cat > kube-proxy-csr.json <<EOF

{
  "CN": "system:kube-proxy",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Hubei",
      "L": "Wuhan",
      "O": "k8s",
      "OU": "system"
    }
  ]
  }
EOF
```

#### 创建证书

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy
```

#### 创建kubeconfig文件

设置集群

```
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://192.168.40.180:6443 --kubeconfig=kube-proxy.kubeconfig
```

设置凭证

```sh
 kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig
```

设置上下文

```
kubectl config set-context default --cluster=kubernetes --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig
```

使用上下文

```sh
kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
```

#### 创建kube-proxy.yaml 配置文件

```sh
cat > kube-proxy.yaml <<EOF
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 192.168.2.131
clientConnection:
  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig
clusterCIDR: 192.168.2.0/24
healthzBindAddress: 192.168.2.131:10256
kind: KubeProxyConfiguration
metricsBindAddress: 192.168.2.131:10249
mode: "ipvs"
EOF
```

```
bindAddress-绑定ip
clusterCIDR-集群所在网段
healthzBindAddress-健康检测地址
mode-IPVS 可以将基于 TCP 和 UDP 服务的请求定向到真实服务器，并使真实服务器的服务在单个IP地址上显示为虚拟服务。 因此，IPVS 自然支持 Kubernetes 服务
```

创建服务

```
cat > kube-proxy.service <<EOF
[Unit]
Description=Kubernetes Kube-Proxy Server
Documentation=https://github.com/kubernetes/kubernetes
After=network.target
 
[Service]
WorkingDirectory=/var/lib/kube-proxy
ExecStart=/usr/local/bin/kube-proxy \
  --config=/etc/kubernetes/kube-proxy.yaml \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2
Restart=on-failure
RestartSec=5
LimitNOFILE=65536
 
[Install]
WantedBy=multi-user.target
EOF
```

#### 移动配置

```sh
scp  kube-proxy.kubeconfig kube-proxy.yaml node:/etc/kubernetes/
scp  kube-proxy.service node:/usr/lib/systemd/system/
```

#### 启动服务

创建工作目录

```sh
mkdir -p /var/lib/kube-proxy
systemctl daemon-reload
systemctl  stop kube-proxy
systemctl enable kube-proxy
systemctl  start kube-proxy
systemctl status kube-proxy
```

### 部署calico组件

calico是k8s集群安装所用到的网络组件，calico与fannel相比具有访问控制功能，复杂性也更高些。在节点加入集群时，如果节点没有安装calico组件，节点会处于NotReady状态。安装方法之前介绍过，可以通过官网下载https://docs.projectcalico.org/getting-started/kubernetes/quickstart  [yaml](https://so.csdn.net/so/search?q=yaml&spm=1001.2101.3001.7020)文件保存为calico.yaml下载到节点本地，将里面的网络域修改为自己设定的网络域，然后安装。比如下载3.8版本的calico，将网络域改为10.244.0.0/16

导入docker镜像

操作服务器：master1

```sh
docker load -i calico.tar.gz
```

启动pod

```sh
kubectl apply -f calico.yaml
```

查看状态

```sh
 kubectl get pods -n kube-system
```

注意需要等待几分钟

```sh
[root@master1 work]#  kubectl get pods -n kube-system
NAME                                       READY   STATUS     RESTARTS   AGE
calico-kube-controllers-6949477b58-8nwhp   0/1     Pending    0          47s
calico-node-hjxmm                          0/1     Init:0/3   0          47s
```



问题1

```sh
Failed to create pod sandbox: rpc error: code = Unknown desc = failed to get sandbox image "k8s.gcr.io/pause:3.2": failed to pull image "k8s.gcr.io/pause:3.2": failed to pull and unpack image "k8s.gcr.io/pause:3.2": failed to resolve reference "k8s.gcr.io/pause:3.2": failed to do request: Head "https://k8s.gcr.io/v2/pause/manifests/3.2": dial tcp 74.125.204.82:443: i/o timeout
```

修改kubelet.service里面的`  --pod-infra-container-image`

```sh
  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2 \
```



```sh
 Readiness probe failed: calico/node is not ready: BIRD is not ready: Failed to stat() nodename file: stat /var/lib/calico/nodename: no such file or directory
```

网上说，修改配置yaml文件到具体的ens。实际上是我的kube-proxy没有启动起来。

![image-20220702162555860](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220702162555860.png)

启动起来以后，导致

```sh
unable to connect to BIRDv4 socket: dial unix /var/run/calico/bird.ctl: connect: connection refused
```

需要删除截图内容！！！！！！

```sh
kubectl get nodes
```

查看内容

```sh
[root@master1 work]# kubectl get nodes
NAME   STATUS   ROLES    AGE    VERSION
node   Ready    <none>   166m   v1.20.7
```

### 部署tomcat集群

#### 查看节点信息

```sh
kubectl get pods
```

#### 安装镜像

tomcat.yaml是部署pod所需东西。tomcat-service.yaml映射所需文件。

```sh
docker load -i tomcat.tar.gz
docker load -i busybox-1-28.tar.gz 
kubectl apply -f tomcat.yaml
kubectl apply -f tomcat-service.yaml
```

上传附录里面的tomcat.tar.gz、busybox-1-28.tar.gz、tomcat.yaml、tomcat-service.yaml。

#### 查看service情况

```sh
kubectl get svc
```

![image-20220703095443500](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220703095443500.png)

#### 测试tomcat的pod情况

```
http://192.168.2.131:30080/
```

#### 测试外网访问情况（cordns）

```
 kubectl run busybox --image busybox:1.28 --restart=Never --rm -it busybox -- sh
```

进入以后

```sh
ping www.baidu.com
```

如果出来了ping不通情况。重装一下。

```sh
kubectl delete -f coredns.yaml
kubectl apply -f coredns.yaml
```

测试内网域名情况

```
nslookup kubernetes.default.svc.cluster.local
nslookup tomcat.default.svc.cluster.local
```

![image-20220703095918154](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220703095918154.png)

### 安装nginx+keepalived实现高可用

nignx本身的upstream可以做反向代理，如果某个apiserver死了，nginx能够转到另外的apiserver。

如果nginx死了，那么就需要keepalived，切换nginx。

#### 安装软件

操作服务器：master1、master2

```sh
yum install nginx keepalived -y
```

#### 配置nginx

注意以下语句会覆盖源文件

```sh
cat > /etc/nginx/nginx.conf<<EOF

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

# 四层负载均衡，为两台Master apiserver组件提供负载均衡
stream {

    log_format  main  '$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent';

    access_log  /var/log/nginx/k8s-access.log  main;

    upstream k8s-apiserver {
       server 192.168.2.128:6443;   # xianchaomaster1 APISERVER IP:PORT
       server 192.168.2.129:6443;   # xianchaomaster2 APISERVER IP:PORT
       server 192.168.2.130:6443;   # xianchaomaster3 APISERVER IP:PORT

    }
    
    server {
       listen 16443; # 由于nginx与master节点复用，这个监听端口不能是6443，否则会冲突
       proxy_pass k8s-apiserver;
    }
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    server {
        listen       80 default_server;
        server_name  _;

        location / {
        }
    }
}
EOF
```

启动nginx

```
systemctl start nginx.service
```

发现提示

```sh
nginx: [emerg] dlopen() "/usr/lib/nginx/modules/ngx_stream_module.so" failed (/usr/lib/nginx/modules/ngx_stream_module.so: cannot open shared object file: No such file or directory) in /etc/nginx/nginx.conf:1
```

安装nginx的modules，以下选一。

```
yum install nginx-mod-stream -y
```

```sh
yum -y install nginx-all-modules.noarch
```

然后

```sh
systemctl start nginx.service
```

启动成功。

发送到另一个节点，一样的操作。

```sh
scp nginx.conf master2:/etc/nginx/
```

#### 配置keepalived

主配置

```sh
cat >/etc/keepalived/keepalived.conf <<EOF
global_defs { 
   notification_email { 
     acassen@firewall.loc 
     failover@firewall.loc 
     sysadmin@firewall.loc 
   } 
   notification_email_from Alexandre.Cassen@firewall.loc  
   smtp_server 127.0.0.1 
   smtp_connect_timeout 30 
   router_id NGINX_MASTER
} 


#vrrp_script：指定检查nginx工作状态脚本（根据nginx状态判断是否故障转移）

vrrp_script check_nginx {
    script "/etc/keepalived/check_nginx.sh"
}

vrrp_instance VI_1 { 
    state MASTER 
    interface ens33  # 修改为实际网卡名
    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的 
    priority 100    # 优先级，备服务器设置 90 
    advert_int 1    # 指定VRRP 心跳包通告间隔时间，默认1秒 
    authentication { 
        auth_type PASS      
        auth_pass 1111 
    }  
    # 虚拟IP
    virtual_ipaddress { 
        192.168.2.132/24
    } 
    track_script {
        check_nginx
    } 
}

```

备配置

```
cat >/etc/keepalived/keepalived.conf <<EOF
global_defs { 
   notification_email { 
     acassen@firewall.loc 
     failover@firewall.loc 
     sysadmin@firewall.loc 
   } 
   notification_email_from Alexandre.Cassen@firewall.loc  
   smtp_server 127.0.0.1 
   smtp_connect_timeout 30 
   router_id NGINX_MASTER
} 


#vrrp_script：指定检查nginx工作状态脚本（根据nginx状态判断是否故障转移）

vrrp_script check_nginx {
    script "/etc/keepalived/check_nginx.sh"
}

vrrp_instance VI_1 { 
    state BACKUP 
    interface ens33  # 修改为实际网卡名
    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的 
    priority 90    # 优先级，备服务器设置 90 
    advert_int 1    # 指定VRRP 心跳包通告间隔时间，默认1秒 
    authentication { 
        auth_type PASS      
        auth_pass 1111 
    }  
    # 虚拟IP
    virtual_ipaddress { 
        192.168.2.132/24
    } 
    track_script {
        check_nginx
    } 
}
```



##### 设置检测脚本

注意不能使用cat命令，因为会导致$被转移。如果要使用需要转义字符。

```sh
vim /etc/keepalived/check_nginx.sh
#!/bin/bash
count=$(ps -ef |grep nginx | grep sbin | egrep -cv "grep|$$")
if [ "$count" -eq 0 ];then
    systemctl stop keepalived
fi

```

授予执行权限

```
chmod +x  /etc/keepalived/check_nginx.sh
```

#### 启动服务

两个节点都开启服务，并设置自启动。

```sh
systemctl start keepalived
systemctl enable nginx keepalived
```

可以看到，虚拟网卡已经存在。

```
ip addr
```

![image-20220703104043252](https://boot-generate.oss-cn-chengdu.aliyuncs.com/img/image-20220703104043252.png)

使用以下方法

```
systemctl start nginx keepalived
systemctl stop nginx
ip addr
```



```sh
sed -i 's#192.168.2.128:6443#192.168.2.132:16443#' /etc/kubernetes/kubelet-bootstrap.kubeconfig
sed -i 's#192.168.2.128:6443#192.168.2.132:16443#' /etc/kubernetes/kubelet.json
sed -i 's#192.168.2.128:6443#192.168.2.132:16443#' /etc/kubernetes/kubelet.kubeconfig
sed -i 's#192.168.2.128:6443#192.168.2.132:16443#' /etc/kubernetes/kube-proxy.yaml
sed -i 's#192.168.2.128:6443#192.168.2.132:16443#' /etc/kubernetes/kube-proxy.kubeconfig
systemctl restart kubelet kube-proxy
```



```sh
cat /etc/kubernetes/kubelet-bootstrap.kubeconfig|grep 192.168.2.132#存在配置
cat /etc/kubernetes/kubelet.json|grep 192.168.2.132#不存在配置
cat /etc/kubernetes/kubelet.kubeconfig|grep 192.168.2.132#存在配置
cat /etc/kubernetes/kube-proxy.yaml|grep 192.168.2.132#不存在配置
cat /etc/kubernetes/kube-proxy.kubeconfig|grep 192.168.2.132#存在配置
```

